#!/usr/bin/env python

##### EXPLORING DATASETS IN WEEK 1 DOCUMENTATION ##### Inefficient code. Completed in Jupyter Notebook. ASK how to show code in Jupyter Notebook format.

import matplotlib.pyplot as plt; import numpy as np; import netCDF4; from netCDF4 import Dataset
import pandas as pd; import numpy.ma as ma; import time as timeit; import os; import math
import itertools; import scipy.io; import mat73 #mat73 should load v7.3 files but takes a long time. ASK.
%matplotlib inline

# 1. Can run each file separately as we want to look at each file separately for now. But below (kind of) loads all files.
year = 1977
for year in range(1977,2010):
    matfile = "{}".format(year)
    name = 'mat'+ matfile
    filename = 'casts_{}.mat'.format(year)
    scipy.io.loadmat(filename)
    year = year + 1
year = 2015
for year in range(2015, 2019):
    matfile = "{}".format(year)
    name = 'mat'+ matfile
    filename = 'casts_{}.mat'.format(year)
    scipy.io.loadmat(filename)
    year = year + 1
mat2011 = mat73.loadmat('casts_2011.mat') #takes a long time. ASK.
mat2012 = scipy.io.loadmat('casts_2012.mat')
mat2013 = mat73.loadmat('casts_2013.mat') #takes a long time. ASK.
mat2014 = scipy.io.loadmat('casts_2012.mat')
# files for 2011 and 2013 are v7.3 files. All others are scipy readable.

# 2a. Convert from .mat file to a more familiar format (pandas df) ... Will try with mat2009. Should implement into Step 1. ASK.
mat2009 = scipy.io.loadmat('casts_2009.mat')
mat2009.keys()
type(mat2009['casts_2009']),mat2009['casts_2009'].shape
type(mat2009['casts_2009'][0][0]),mat2009['casts_2009'][0][0].shape
mat2009['casts_2009'][0][0]['cast'], mat2009['casts_2009'][0][0]['depth']
[item.flat[0] for item in mat2009['casts_2009'][0][0]]

data = [[row.flat[0] for row in line] for line in mat2009['casts_2009'][0]] #perhaps wrong. Can't do 'explode' to open series. ASK. Perhaps should not do pandas.
columns = ['cast','lat', 'lon', 'yr', 'yd', 'dyd','depth','pc','vn','np','s','t','p','cru','opsid','gear']
df_2009 = pd.DataFrame(data, columns=columns)
print(df_2009) 

# 2b. Try working in numpy. Seems better for this than pandas.
print(type(mat2009))
print(mat2009.keys())
print(type(mat2009['casts_2009']))
np2012 = mat2009['casts_2009']
print(np2012.dtype.names)
np2012depth = [np2012['depth']] #takes a closer look. Array of arrays (nested arrays)
np2012pc = [np2012['pc']]
np2012vn = [np2012['vn']]
np2012s = [np2012['s']]
np2012t = [np2012['t']]
np2012p = [np2012['p']]
print('--depth--',np2012depth)
print('--pc--',np2012pc)
print('--vn--',np2012vn)
print('--s--',np2012s)
print('--t--',np2012t)
print('--p--',np2012p) #want to match each p, t, s etc. using indices. TRY: Below shows accessing into nested array 1 for p and t.
p1 = [i[0][0] for i in np2012p]
t1 = [i[0][0] for i in np2012t]
p1list = list(p1[0][0])
t1list = list(t1[0][0])
df_pandt = pd.DataFrame({'p':p1list,'t':t1list})
print(df_pandt)

plt.figure(figsize=(6, 6)) #making a brief t and p plot.
ax = plt.axes() 
ax.yaxis.grid() # horizontal lines
ax.xaxis.grid() # vertical lines
ax = plt.gca()
ax.grid(True)
plt.xlabel('Temp',fontsize=18)
plt.ylabel('Pressure',fontsize=18)
plt.plot(df_pandt['t'],df_pandt['p']*-1,color='blue')
ax.tick_params(axis = 'both', which = 'major', labelsize = 14)
ax.tick_params(axis = 'both', which = 'minor', labelsize = 14)
plt.show()

# 3. Plot some exploratory graphs
plt.style.use('seaborn-whitegrid')
     # Plotting locations of data collection from all 'gears'
import cartopy; import cartopy.crs as ccrs; from cartopy.mpl.gridliner; import LONGITUDE_FORMATTER, LATITUDE_FORMATTER

latitude = df_2009['lat']
longitude = df_2009['lon']
longitudeneg = -1 * longitude
latitudeneg = 1 * latitude

plt.figure(figsize=(8, 8))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent([-78, -65, 34, 44.5], ccrs.PlateCarree())
ax.coastlines(resolution='110m')
ax.add_feature(cartopy.feature.STATES, linewidth=1.5, edgecolor='black',alpha=0.3)
ax.add_feature(cartopy.feature.COASTLINE)
gl = ax.gridlines(crs=ccrs.PlateCarree(), draw_labels=True,linewidth=1, color='gray', alpha=0.5, linestyle='--')
gl.xlabels_top = False
gl.ylabels_left = False
gl.xformatter = LONGITUDE_FORMATTER
gl.yformatter = LATITUDE_FORMATTER
plt.title('Data Collection Locations', size = 22)
plt.plot(longitudeneg, latitudeneg,  linewidth=0, markersize=0.7, marker='o', color='red')
plt.show()

# Exploring data availability
newlat = []
countinorder = []
for value in countinorder:
     # continue from here !!!
